/// <reference types="node" />
import type { BSONSerializeOptions, Document, ObjectId } from '../bson';
import type { AutoEncrypter } from '../client-side-encryption/auto_encrypter';
import type { ServerApi, SupportedNodeConnectionOptions } from '../mongo_client';
import { type CancellationToken, TypedEventEmitter } from '../mongo_types';
import type { ReadPreferenceLike } from '../read_preference';
import { type ClientSession } from '../sessions';
import { type Callback, HostAddress, type MongoDBNamespace } from '../utils';
import type { WriteConcern } from '../write_concern';
import type { AuthContext } from './auth/auth_provider';
import type { MongoCredentials } from './auth/mongo_credentials';
import { CommandFailedEvent, CommandStartedEvent, CommandSucceededEvent } from './command_monitoring_events';
import { type BinMsg, type Response } from './commands';
import type { Stream } from './connect';
import type { ClientMetadata } from './handshake/client_metadata';
import { MessageStream, type OperationDescription } from './message_stream';
import { StreamDescription, type StreamDescriptionOptions } from './stream_description';
/** @internal */
declare const kStream: unique symbol;
/** @internal */
declare const kQueue: unique symbol;
/** @internal */
declare const kMessageStream: unique symbol;
/** @internal */
declare const kGeneration: unique symbol;
/** @internal */
declare const kLastUseTime: unique symbol;
/** @internal */
declare const kClusterTime: unique symbol;
/** @internal */
declare const kDescription: unique symbol;
/** @internal */
declare const kHello: unique symbol;
/** @internal */
declare const kAutoEncrypter: unique symbol;
/** @internal */
declare const kDelayedTimeoutId: unique symbol;
/** @internal */
export interface CommandOptions extends BSONSerializeOptions {
    secondaryOk?: boolean;
    /** Specify read preference if command supports it */
    readPreference?: ReadPreferenceLike;
    monitoring?: boolean;
    socketTimeoutMS?: number;
    /** Session to use for the operation */
    session?: ClientSession;
    documentsReturnedIn?: string;
    noResponse?: boolean;
    omitReadPreference?: boolean;
    willRetryWrite?: boolean;
    writeConcern?: WriteConcern;
}
/** @public */
export interface ProxyOptions {
    proxyHost?: string;
    proxyPort?: number;
    proxyUsername?: string;
    proxyPassword?: string;
}
/** @public */
export interface ConnectionOptions extends SupportedNodeConnectionOptions, StreamDescriptionOptions, ProxyOptions {
    id: number | '<monitor>';
    generation: number;
    hostAddress: HostAddress;
    /** @internal */
    autoEncrypter?: AutoEncrypter;
    serverApi?: ServerApi;
    monitorCommands: boolean;
    /** @internal */
    connectionType?: typeof Connection;
    credentials?: MongoCredentials;
    connectTimeoutMS?: number;
    tls: boolean;
    noDelay?: boolean;
    socketTimeoutMS?: number;
    cancellationToken?: CancellationToken;
    metadata: ClientMetadata;
}
/** @internal */
export interface DestroyOptions {
    /** Force the destruction. */
    force: boolean;
}
/** @public */
export type ConnectionEvents = {
    commandStarted(event: CommandStartedEvent): void;
    commandSucceeded(event: CommandSucceededEvent): void;
    commandFailed(event: CommandFailedEvent): void;
    clusterTimeReceived(clusterTime: Document): void;
    close(): void;
    message(message: any): void;
    pinned(pinType: string): void;
    unpinned(pinType: string): void;
};
/** @internal */
export declare class Connection extends TypedEventEmitter<ConnectionEvents> {
    id: number | '<monitor>';
    address: string;
    socketTimeoutMS: number;
    monitorCommands: boolean;
    /** Indicates that the connection (including underlying TCP socket) has been closed. */
    closed: boolean;
    lastHelloMS?: number;
    serverApi?: ServerApi;
    helloOk?: boolean;
    commandAsync: (ns: MongoDBNamespace, cmd: Document, options: CommandOptions | undefined) => Promise<Document>;
    /** @internal */
    authContext?: AuthContext;
    /**@internal */
    [kDelayedTimeoutId]: NodeJS.Timeout | null;
    /** @internal */
    [kDescription]: StreamDescription;
    /** @internal */
    [kGeneration]: number;
    /** @internal */
    [kLastUseTime]: number;
    /** @internal */
    [kQueue]: Map<number, OperationDescription>;
    /** @internal */
    [kMessageStream]: MessageStream;
    /** @internal */
    [kStream]: Stream;
    /** @internal */
    [kHello]: Document | null;
    /** @internal */
    [kClusterTime]: Document | null;
    /** @event */
    static readonly COMMAND_STARTED: "commandStarted";
    /** @event */
    static readonly COMMAND_SUCCEEDED: "commandSucceeded";
    /** @event */
    static readonly COMMAND_FAILED: "commandFailed";
    /** @event */
    static readonly CLUSTER_TIME_RECEIVED: "clusterTimeReceived";
    /** @event */
    static readonly CLOSE: "close";
    /** @event */
    static readonly MESSAGE: "message";
    /** @event */
    static readonly PINNED: "pinned";
    /** @event */
    static readonly UNPINNED: "unpinned";
    constructor(stream: Stream, options: ConnectionOptions);
    get description(): StreamDescription;
    get hello(): Document | null;
    set hello(response: Document | null);
    set isMonitoringConnection(value: boolean);
    get isMonitoringConnection(): boolean;
    get serviceId(): ObjectId | undefined;
    get loadBalanced(): boolean;
    get generation(): number;
    set generation(generation: number);
    get idleTime(): number;
    get clusterTime(): Document | null;
    get stream(): Stream;
    markAvailable(): void;
    onError(error: Error): void;
    onClose(): void;
    onTimeout(): void;
    onMessage(message: BinMsg | Response): void;
    destroy(options: DestroyOptions, callback?: Callback): void;
    /**
     * A method that cleans up the connection.  When `force` is true, this method
     * forcibly destroys the socket.
     *
     * If an error is provided, any in-flight operations will be closed with the error.
     *
     * This method does nothing if the connection is already closed.
     */
    private cleanup;
    command(ns: MongoDBNamespace, command: Document, options: CommandOptions | undefined, callback: Callback): void;
}
/** @internal */
export declare class CryptoConnection extends Connection {
    /** @internal */
    [kAutoEncrypter]?: AutoEncrypter;
    constructor(stream: Stream, options: ConnectionOptions);
    /** @internal @override */
    command(ns: MongoDBNamespace, cmd: Document, options: CommandOptions, callback: Callback): void;
}
/** @internal */
export declare function hasSessionSupport(conn: Connection): boolean;
export {};
//# sourceMappingURL=connection.d.ts.map